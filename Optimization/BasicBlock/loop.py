#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@Time : 17-6-12 下午10:09

@Author : hellolzc axiqia
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import copy
from yaspc.Optimization.BasicBlock import BasicBlock
from yaspc.Optimization.BasicBlock import ud
from yaspc.Optimization.Instruction import instruction

DEBUG = False

# Loop-invariant code motion – this can vastly improve efficiency by moving a computation
#  from inside the loop to outside of it, computing a value just once before the loop begins,
#  if the resultant quantity of the calculation will be the same for every loop iteration
#  (i.e., a loop-invariant quantity). This is particularly important with address-calculation
#  expressions generated by loops over arrays. For correct implementation, this technique
#  must be used with inversion, because not all code is safe to be moved outside the loop.

def find_dominator(block_list):
    """ find dominator of all blocks
    In control flow graphs, a node d dominates a node n
    if every path from the entry node to n must go through d.
    Notationally, this is written as d dom n (or sometimes d >> n).
    By definition, every node dominates itself.
    参考蒋立源、康慕宁《编译原理》P312程序8-4
    """
    # init set N, D
    N = set()
    for i in range(len(block_list)):
        N.add(i)
    if DEBUG:
        print(N)
    # The sets of dominator of all nodes
    D = dict()
    for i in range(len(block_list)):
        D[i] = set()
    D[0].add(0)
    for i in range(1, len(block_list)):
        D[i] = N
    change = True
    if DEBUG:
        print(D)
    while change:
        change = False
        for i in range(1, len(block_list)):
            block = block_list[i]
            newD = copy.deepcopy(N)
            for pre_block in block.preBasicBlock:
                newD = newD & D[pre_block.blockNum]
            newD.add(i)
            if D[i] != newD:
                change = True
                D[i] = newD
    print(D)
    return D


def __insert(n, loop, stack):
    if n not in loop:
        loop = loop.add(n)
        stack.append(n)


def find_loop(d, n, block_list):
    """给定回边 n->d，确定此循环的全部节点
    参考蒋立源、康慕宁《编译原理》P314程序8-5
    loop : The set of blockNum in the loop
    """
    stack = list()
    loop = set()

    loop.add(d)
    __insert(n, loop, stack)
    while len(stack) > 0:
        m = stack.pop()
        block = block_list[m]
        for pre_block in block.preBasicBlock:
            __insert(pre_block.blockNum, loop, stack)
    return loop

def find_loop_exit(block_list, loop):
    """find the exit blocks of a loop
    return a list of blockNum
    """
    exit_blockNum = []
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for succ, _ in block.succBasicBlock:
            if not succ.blockNum in loop:
                exit_blockNum.append(block.blockNum)
    return exit_blockNum


def __mark_unchanged_computation(block_list, loop):
    """对于循环L中的四元式r，若 "它的各运算对象是常数，或者是定值点在L之外的变量"，或者
    "虽然在L中的某一点s定值，但该点是唯一能到达r的且已标记的定值点"，则标记四元式r
    参考蒋立源、康慕宁《编译原理》P315
    等价描述：先找到各运算对象是常数，或者是定值点在L之外的变量的四元式，处理这个四元式后，重复进行标记工作
    Parameters :
        block_list :
        loop : The set of blockNum in the loop
    Add unchanged_flag attribution for instructions in loop
    Attention: You must analysis reaching definitions first
    """
    inst_set_of_loop = set()
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            inst_set_of_loop.add(inst.pos)
            # init the unchanged_flag of all instructions
            inst.unchanged_flag = False
        changed_flag = True
        while changed_flag:
            changed_flag = False
            for inst in block:
                if inst.unchanged_flag == True:
                    continue
                # BinaryInst
                if isinstance(inst, instruction.BinaryInst):
                    left_flag = False
                    right_flag = False
                    # check left operand
                    if inst.is_left_a_variable is False:
                        left_flag = True
                    else:
                        left_ud = inst.left_ud
                        ud_in_L = tuple(left_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            left_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            left_flag = True
                    # check right operand
                    if inst.is_right_a_variable is False:
                        right_flag = True
                    else:
                        right_ud = inst.right_ud
                        ud_in_L = tuple(right_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            right_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            right_flag = True
                    # make a dicision
                    if left_flag and right_flag:
                        inst.unchanged_flag = True
                        changed_flag = True
                # UnaryInst
                elif isinstance(inst, instruction.UnaryInst):
                    if inst.is_variable_a_variable is False:
                        inst.unchanged_flag = True
                        changed_flag = True
                    else:
                        var_ud = inst.var_ud
                        ud_in_L = tuple(var_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            inst.unchanged_flag = True
                            changed_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            inst.unchanged_flag = True
                            changed_flag = True

def __check_whether_expression_can_be_hoisted(block_list, loop, the_block, the_inst, D, var_reduce):
    """对循环L中每一个不变运算s:
        (s)  A := B OP C 或 A := OP B
       可以提出到循环外的运算必须满足下面条件：
        (1)s是L中A的唯一定值点。
        (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
        (3) a. s所在的基本块是L的各出口节点的必经节点
        或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
    """
    inst_set_of_loop = set()
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            inst_set_of_loop.add(inst.pos)
    # (1)s是L中A的唯一定值点
    var_A_name = the_inst.value.name
    var_reduce_in_loop = var_reduce[var_A_name] & inst_set_of_loop
    if not len(var_reduce_in_loop) == 1:
        return False

    # (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            if isinstance(inst, instruction.BinaryInst):
                if len(inst.left_ud) != 1 or inst.left_ud[0] != the_inst.pos:
                    return False
    # (3) a. s所在的基本块是L的各出口节点的必经节点
    # 或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
    exit_blocks = find_loop_exit(block_list, loop)
    for block in block_list:
        if not block.blockNum in exit_blocks:
            continue
        if not the_block.blockNum in D[block.blockNum]:
            return False
    # 三个条件均满足，返回真
    return True

def __hoist_expression(block_list, loop_dict, the_block, the_inst):
    """
    先查找循环的前置节点，再将符合条件的算式提前
    """
    entrance_blockNum = loop_dict['entrance']
    for block in block_list:
        if block.blockNum == entrance_blockNum:
            entrance_block = block
    pre_entrance_block_list = entrance_block.preBasicBlock
    if len(pre_entrance_block_list) == 1:
        pre_entrance_block = pre_entrance_block_list[0]
        pre_entrance_block.instlist.append(the_inst)
        the_block.instList.pop(the_inst)
    else:
        return


def hoist_loop_invariant_expressions(block_list, loop_dict, D, var_reduce):
    """Loop-invariant expressions can be hoisted out of loops
        Attention: You must analysis reaching definitions first
        参考蒋立源、康慕宁《编译原理》P317。
        求出L中全部不变运算后，对每一个不变运算s:
        (s)  A := B OP C 或 A := OP B
        可以提出到循环外的运算必须满足下面条件：
             (1)s是L中A的唯一定值点。
             (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
             (3) a. s所在的基本块是L的各出口节点的必经节点
             或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
        之后，可以按查找时的顺序，将符合条件的不变运算移至前置节点
    """
    # mark unchanged computation
    __mark_unchanged_computation(block_list, loop_dict['loop'])
    # find computation which can be moved
    for block in block_list:
        if not block.blockNum in loop_dict['loop']:
            continue
        for inst in block:
            if inst.unchanged_flag is True:
                if __check_whether_expression_can_be_hoisted(block_list, loop_dict['loop'], block, inst, D, var_reduce):
                    # Loop-invariant expressions can be hoisted out of loops
                    __hoist_expression(block_list, loop_dict, block, inst)



def do_loop_optimization(block_list):
    """the main function of Loop optimization
    """
    # find dominator
    D = find_dominator(block_list)

    # find loop
    loop_info_dict = dict()
    count = 0
    for n in range(len(D)):
        dom_set = D[n]
        for d in dom_set:
            for succ, description in block_list[n].succBasicBlock:
                if succ == block_list[d]:
                    count = count + 1
                    print("find a back edge %d -> %d"%(n, d))
                    loop = find_loop(d, n, block_list)
                    loop_info_dict[count] = {"loop":loop, "entrance":d}

    if count == 0:
        print("No Loop founded")
        return
    print('find %d loops'%count)
    print(loop_info_dict)
    # analysis reaching definitions
    var_reduce = ud.reach_def_iteration(block_list)
    ud.ud_set(block_list, var_reduce)

    for loop_dict in loop_info_dict:
        # Loop-invariant expressions can be hoisted out of loops
        hoist_loop_invariant_expressions(block_list, loop_dict, D, var_reduce)

