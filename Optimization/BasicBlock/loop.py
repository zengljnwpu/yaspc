#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@Time : 17-6-12 下午10:09

@Author : hellolzc axiqia
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import copy
from yaspc.Optimization.BasicBlock import BasicBlock
from yaspc.Optimization.BasicBlock import ud
from yaspc.Optimization.Instruction import instruction

DEBUG = False

# Loop-invariant code motion – this can vastly improve efficiency by moving a computation
#  from inside the loop to outside of it, computing a value just once before the loop begins,
#  if the resultant quantity of the calculation will be the same for every loop iteration
#  (i.e., a loop-invariant quantity). This is particularly important with address-calculation
#  expressions generated by loops over arrays. For correct implementation, this technique
#  must be used with inversion, because not all code is safe to be moved outside the loop.


def find_dominator(block_list):
    """ find dominator of all blocks
    In control flow graphs, a node d dominates a node n
    if every path from the entry node to n must go through d.
    Notationally, this is written as d dom n (or sometimes d >> n).
    By definition, every node dominates itself.
    参考蒋立源、康慕宁《编译原理》P312程序8-4
    """
    # init set N, D
    N = set()
    for i in range(len(block_list)):
        N.add(i)
    # print(N)
    # The sets of dominator of all nodes
    D = dict()
    for i in range(len(block_list)):
        D[i] = set()
    D[0].add(0)
    for i in range(1, len(block_list)):
        D[i] = N
    change = True
    # print(D)
    while change:
        change = False
        for i in range(1, len(block_list)):
            block = block_list[i]
            newD = copy.deepcopy(N)
            for pre_block in block.preBasicBlock:
                newD = newD & D[pre_block.blockNum]
            newD.add(i)
            if D[i] != newD:
                change = True
                D[i] = newD
    print('===========DOMINATOR SET==============')
    for key in D:
        print(key, D[key])
    return D


def __insert(n, loop, stack):
    if n not in loop:
        loop.add(n)
        stack.append(n)


def find_loop(d, n, block_list):
    """给定回边 n->d，确定此循环的全部节点
    参考蒋立源、康慕宁《编译原理》P314程序8-5
    loop : The set of blockNum in the loop
    """
    stack = list()
    loop = set()

    loop.add(d)
    __insert(n, loop, stack)
    while len(stack) > 0:
        m = stack.pop()
        block = block_list[m]
        for pre_block in block.preBasicBlock:
            __insert(pre_block.blockNum, loop, stack)
    return loop


def find_loop_exit(block_list, loop):
    """find the exit blocks of a loop
    return a list of blockNum
    """
    exit_blockNum = []
    for block in block_list:
        if block.blockNum not in loop:
            continue
        for succ, _ in block.succBasicBlock:
            if not succ.blockNum in loop:
                exit_blockNum.append(block.blockNum)
    return exit_blockNum


def __mark_unchanged_computation(block_list, loop, var_reduce):
    """对于循环L中的四元式r，若 (1)"它的各运算对象是常数，或者是定值点在L之外的变量"，或者
    (2)"虽然在L中的某一点s定值，但该点是唯一能到达r的且已标记的定值点"，则标记四元式r
    参考蒋立源、康慕宁《编译原理》P315
    等价描述：先找到各运算对象是常数，或者是定值点在L之外的变量的四元式，
    处理这个四元式后，重复进行标记工作，即先考虑条件(1)，通过循环进行满足条件(2)
    Parameters :
        block_list :
        loop : The set of blockNum in the loop
    Add unchanged_flag attribution for instructions in loop
    Attention: You must analysis reaching definitions first
    """
    inst_set_of_loop = set()
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block.instList:
            inst_set_of_loop.add(inst.pos)
            # init the unchanged_flag of all instructions
            inst.unchanged_flag = False
    if DEBUG:
        print("inst_set_of_loop:")
        print(inst_set_of_loop)

    for block in block_list:
        if not block.blockNum in loop:
            continue
        loop_changed_flag = True
        while loop_changed_flag:
            loop_changed_flag = False
            for inst in block.instList:
                if inst.unchanged_flag == True:
                    continue
                # BinaryInst
                if isinstance(inst, instruction.BinaryInst):
                    left_flag = False
                    right_flag = False
                    # check left operand
                    if inst.left.is_value():
                        left_flag = True
                    else:
                        # print(var_reduce[inst.left.name])
                        ud_in_loop = set(var_reduce[inst.left.name]) & inst_set_of_loop
                        if len(ud_in_loop) == 0:
                            # definition is out of L
                            left_flag = True
                    # check right operand
                    if inst.right.is_value():
                        right_flag = True
                    else:
                        # print(var_reduce[inst.right.name])
                        ud_in_loop = set(var_reduce[inst.right.name]) & inst_set_of_loop
                        if len(ud_in_loop) == 0:
                            # definition is out of L
                            right_flag = True
                    # make a dicision
                    if left_flag and right_flag:
                        inst.unchanged_flag = True
                        loop_changed_flag = True
                # UnaryInst
                elif isinstance(inst, instruction.UnaryInst):
                    if inst.variable.is_value():
                        inst.unchanged_flag = True
                        loop_changed_flag = True
                    else:
                        ud_in_loop = set(var_reduce[inst.variable.name]) & inst_set_of_loop
                        if len(ud_in_loop) == 0:
                            # definition is out of L
                            inst.unchanged_flag = True
                            loop_changed_flag = True
    if DEBUG:
        print("=======Unchanged Computation=======")
        print("pos\tunchanged_flag\tinst")
        for block in block_list:
            if not block.blockNum in loop:
                continue
            for inst in block.instList:
                print('%d\t%s\t%s'%(inst.pos, str(inst.unchanged_flag), str(inst)))


def __check_whether_expression_can_be_hoisted(block_list, loop, the_block, the_inst, D, var_reduce):
    """对循环L中每一个不变运算s:
        (s)  A := B OP C 或 A := OP B
       可以提出到循环外的运算必须满足下面条件：
        (1)s是L中A的唯一定值点。
        (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
        (3) a. s所在的基本块是L的各出口节点的必经节点
        或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
    """
    inst_set_of_loop = set()
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block.instList:
            inst_set_of_loop.add(inst.pos)
    # (1)s是L中A的唯一定值点
    if DEBUG:
        print('Test condition 1...')
    var_A_name = the_inst.value.name
    var_reduce_in_loop = set(var_reduce[var_A_name]) & inst_set_of_loop
    if not len(var_reduce_in_loop) == 1:
        return False

    # (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
    if DEBUG:
        print('Test condition 2...')
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block.instList:
            if isinstance(inst, instruction.BinaryInst):
                if inst.left.is_variable() and inst.left.name == var_A_name:
                    # print(inst.left_ud)
                    if len(inst.left_ud) != 1 or inst.left_ud[0] != the_inst.pos:
                        return False
                if inst.right.is_variable() and inst.right.name == var_A_name:
                    # print(inst.right_ud)
                    if len(inst.right_ud) != 1 or inst.right_ud[0] != the_inst.pos:
                        return False
            if isinstance(inst, instruction.UnaryInst):
                if inst.variable.is_variable() and inst.variable.name == var_A_name:
                    # print(inst.var_ud)
                    if len(inst.var_ud) != 1 or inst.var_ud[0] != the_inst.pos:
                        return False
    # (3) a. s所在的基本块是L的各出口节点的必经节点
    #
    # 或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
    if DEBUG:
        print('Test condition 3...')
    exit_blocks = find_loop_exit(block_list, loop)
    for block in block_list:
        if block.blockNum not in exit_blocks:
            continue
        if the_block.blockNum not in D[block.blockNum]:
            # print('%d not in %s'%(the_block.blockNum, str(D[block.blockNum])))
            return False
    # 三个条件均满足，返回真
    return True

def __hoist_expression(block_list, loop_dict, the_block, the_inst):
    """
    先查找循环的前置节点，再将符合条件的算式提前
    成功提前则返回True
    """
    entrance_blockNum = loop_dict['entrance']
    for block in block_list:
        if block.blockNum == entrance_blockNum:
            entrance_block = block
            break
    # print(entrance_block.preBasicBlock)

    pre_entrance_block_list = []
    for pre_block in entrance_block.preBasicBlock:
        if pre_block.blockNum not in loop_dict['loop']:
            # 前置节点必须只有一个出口
            if len(pre_block.succBasicBlock) == 1:
                pre_entrance_block_list.append(pre_block)
            else:
                return False

    for pre_block in pre_entrance_block_list:
        # 插入指令
        if isinstance(pre_block.get_last_inst(), (instruction.CJumpInst, instruction.JumpInst)):
            pre_block.instList.insert(-1, the_inst)
        else:
            pre_block.instList.append(the_inst)
    for num, inst in enumerate(the_block.instList):
        if inst.pos == the_inst.pos:
            the_block.instList.pop(num)
            return True



def hoist_loop_invariant_expressions(block_list, loop_dict, D, var_reduce):
    """Loop-invariant expressions can be hoisted out of loops
        Attention: You must analysis reaching definitions first
        参考蒋立源、康慕宁《编译原理》P317。
        求出L中全部不变运算后，对每一个不变运算s:
        (s)  A := B OP C 或 A := OP B
        可以提出到循环外的运算必须满足下面条件：
             (1)s是L中A的唯一定值点。
             (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
             (3) a. s所在的基本块是L的各出口节点的必经节点
             或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
        之后，可以按查找时的顺序，将符合条件的不变运算移至前置节点
    """
    loop_changed_flag = True
    while loop_changed_flag:
        loop_changed_flag = False
        # mark unchanged computation
        __mark_unchanged_computation(block_list, loop_dict['loop'], var_reduce)
        # find computation which can be moved
        for block in block_list:
            if not block.blockNum in loop_dict['loop']:
                continue
            for inst in block.instList:
                if inst.unchanged_flag is True:
                    if __check_whether_expression_can_be_hoisted(block_list, loop_dict['loop'], block, inst, D, var_reduce):
                        if DEBUG:
                            print("Loop-invariant expression Found\n")
                        # Loop-invariant expressions can be hoisted out of loops
                        loop_changed_flag = __hoist_expression(block_list, loop_dict, block, inst)



def do_loop_optimization(block_list, debug_print=True):
    """the main function of Loop optimization
    """
    global DEBUG
    DEBUG = debug_print
    # find dominator
    D = find_dominator(block_list)

    # find loop
    loop_info_dict = dict()
    count = 0
    for n in range(len(D)):
        dom_set = D[n]
        for d in dom_set:
            for succ, description in block_list[n].succBasicBlock:
                if succ == block_list[d]:
                    count = count + 1
                    print("\nFind a back edge %d -> %d"%(n, d))
                    loop = find_loop(d, n, block_list)
                    loop_info_dict[count] = {"loop":loop, "entrance":d}

    if count == 0:
        print("No Loop founded")
        return
    print('Find %d loops:'%count)
    for key in loop_info_dict:
        print(key, '\tEntrance:', loop_info_dict[key]['entrance'])
        print('\tBlocks in loop:', loop_info_dict[key]['loop'])
    # analysis reaching definitions
    var_reduce = ud.reach_def_iteration(block_list)
    ud.ud_set(block_list, var_reduce)

    for Num in loop_info_dict:
        # Loop-invariant expressions can be hoisted out of loops
        hoist_loop_invariant_expressions(block_list, loop_info_dict[Num], D, var_reduce)

