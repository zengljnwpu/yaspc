#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@Time : 17-6-12 下午10:09

@Author : hellolzc axiqia
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import copy
from yaspc.Optimization.BasicBlock import BasicBlock
from yaspc.Optimization.BasicBlock import ud
from yaspc.Optimization.Instruction import instruction

DEBUG = False

# Loop-invariant code motion – this can vastly improve efficiency by moving a computation
#  from inside the loop to outside of it, computing a value just once before the loop begins,
#  if the resultant quantity of the calculation will be the same for every loop iteration
#  (i.e., a loop-invariant quantity). This is particularly important with address-calculation
#  expressions generated by loops over arrays. For correct implementation, this technique
#  must be used with inversion, because not all code is safe to be moved outside the loop.

def find_dominator(block_list):
    """ find dominator of all blocks
    In control flow graphs, a node d dominates a node n
    if every path from the entry node to n must go through d.
    Notationally, this is written as d dom n (or sometimes d >> n).
    By definition, every node dominates itself.
    参考蒋立源、康慕宁《编译原理》P312程序8-4
    """
    # init set N, D
    N = set()
    for i in range(len(block_list)):
        N.add(i)
    if DEBUG:
        print(N)
    # The sets of dominator of all nodes
    D = dict()
    for i in range(len(block_list)):
        D[i] = set()
    D[0].add(0)
    for i in range(1, len(block_list)):
        D[i] = N
    change = True
    if DEBUG:
        print(D)
    while change:
        change = False
        for i in range(1, len(block_list)):
            block = block_list[i]
            newD = copy.deepcopy(N)
            for pre_block in block.preBasicBlock:
                newD = newD & D[pre_block.blockNum]
            newD.add(i)
            if D[i] != newD:
                change = True
                D[i] = newD
    print(D)
    return D


def __insert(n, loop, stack):
    if n not in loop:
        loop = loop.add(n)
        stack.append(n)


def find_loop(d, n, block_list):
    """给定回边 n->d，确定此循环的全部节点
    参考蒋立源、康慕宁《编译原理》P314程序8-5
    loop : The set of blockNum in the loop
    """
    stack = list()
    loop = set()

    loop.add(d)
    __insert(n, loop, stack)
    while len(stack) > 0:
        m = stack.pop()
        block = block_list[m]
        for pre_block in block.preBasicBlock:
            __insert(pre_block.blockNum, loop, stack)
    return loop

def __is_operand_define_out_loop(inst, operand, var_ud, inst_set_of_loop):
    if instruction.is_operand_a_variable(operand) is False:
        return True
    else:
        ud_in_L = tuple(var_ud & inst_set_of_loop)
        if len(ud_in_L) == 0:
            # definition is out of L
            return True
        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                    ud_in_L[0].changed_flag == True:
            # definition is in L and is a unchanged computation
            return True

def __mark_unchanged_computation(block_list, loop):
    """对于循环L中的四元式r，若 "它的各运算对象是常数，或者是定值点在L之外的变量"，或者
    "虽然在L中的某一点s定值，但该点是唯一能到达r的且已标记的定值点"，则标记四元式r
    参考蒋立源、康慕宁《编译原理》P315
    Parameters :
        block_list :
        loop : The set of blockNum in the loop
    Add unchanged_flag attribution for instructions in loop
    Attention: You must analysis reaching definitions first
    """
    inst_set_of_loop = set()
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            inst_set_of_loop.add(inst.pos)
            inst.unchanged_flag = False
        changed_flag = True
        while changed_flag:
            changed_flag = False
            for inst in block:
                if inst.unchanged_flag == True:
                    continue
                # BinaryInst
                if isinstance(inst, instruction.BinaryInst):
                    left_flag = False
                    right_flag = False
                    # check left operand
                    if inst.is_left_a_variable is False:
                        left_flag = True
                    else:
                        left_ud = inst.left_ud
                        ud_in_L = tuple(left_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            left_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            left_flag = True
                    # check right operand
                    if inst.is_right_a_variable is False:
                        right_flag = True
                    else:
                        right_ud = inst.right_ud
                        ud_in_L = tuple(right_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            right_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            right_flag = True
                    # make a dicision
                    if left_flag and right_flag:
                        inst.unchanged_flag = True
                        changed_flag = True
                # UnaryInst
                elif isinstance(inst, instruction.UnaryInst):
                    if inst.is_variable_a_variable is False:
                        inst.unchanged_flag = True
                        changed_flag = True
                    else:
                        var_ud = inst.var_ud
                        ud_in_L = tuple(var_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            inst.unchanged_flag = True
                            changed_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            inst.unchanged_flag = True
                            changed_flag = True

def __check_whether_expression_can_be_hoisted():
    """
    """
    pass

def __hoist_loop_invariant_expressions():
    """Loop-invariant expressions can be hoisted out of loops
        参考蒋立源、康慕宁《编译原理》P317。
        求出L中全部不变运算后，对每一个不变运算s:
        (s)  A := B OP C 或 A := OP B
        可以提出到循环外的运算必须满足下面条件：
             (1)s是L中A的唯一定值点。
             (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
             (3) a. s所在的基本块是L的各出口节点的必经节点
             或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
        之后，可以按查找时的顺序，将符合条件的不变运算移至前置节点
    """
    pass

def do_loop_optimization(block_list):
    """the main function of Loop optimization
    """
    # find dominator
    D = find_dominator(block_list)
    # find loop
    loop_list = list()
    for n in range(len(D)):
        dom_set = D[n]
        for d in dom_set:
            for succ, description in block_list[n].succBasicBlock:
                if succ == block_list[d]:
                    print("find a back edge %d -> %d"%(n, d))
                    loop = find_loop(d, n, block_list)
                    loop_list.append(loop)
    print(loop_list)
    # analysis reaching definitions
    var_reduce = ud.reach_def_iteration(block_list)
    ud.ud_set(block_list, var_reduce)
    # mark unchanged computation
    for loop in loop_list:
        __mark_unchanged_computation(block_list, loop)
    # find computation which can be moved
    # Loop-invariant expressions can be hoisted out of loops
