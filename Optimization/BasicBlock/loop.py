#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@Time : 17-6-12 下午10:09

@Author : hellolzc axiqia
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import copy
from yaspc.Optimization.BasicBlock import BasicBlock
from yaspc.Optimization.BasicBlock import ud
from yaspc.Optimization.Instruction import instruction

DEBUG = False

# Loop-invariant code motion – this can vastly improve efficiency by moving a computation
#  from inside the loop to outside of it, computing a value just once before the loop begins,
#  if the resultant quantity of the calculation will be the same for every loop iteration
#  (i.e., a loop-invariant quantity). This is particularly important with address-calculation
#  expressions generated by loops over arrays. For correct implementation, this technique
#  must be used with inversion, because not all code is safe to be moved outside the loop.

def find_dominator(block_list):
    """ find dominator of all blocks
    In control flow graphs, a node d dominates a node n
    if every path from the entry node to n must go through d.
    Notationally, this is written as d dom n (or sometimes d >> n).
    By definition, every node dominates itself.
    参考蒋立源、康慕宁《编译原理》P312程序8-4
    """
    # init set N, D
    N = set()
    for i in range(len(block_list)):
        N.add(i)
    if DEBUG:
        print(N)
    # The sets of dominator of all nodes
    D = dict()
    for i in range(len(block_list)):
        D[i] = set()
    D[0].add(0)
    for i in range(1, len(block_list)):
        D[i] = N
    change = True
    if DEBUG:
        print(D)
    while change:
        change = False
        for i in range(1, len(block_list)):
            block = block_list[i]
            newD = copy.deepcopy(N)
            for pre_block in block.preBasicBlock:
                newD = newD & D[pre_block.blockNum]
            newD.add(i)
            if D[i] != newD:
                change = True
                D[i] = newD
    print(D)
    return D


def __insert(n, loop, stack):
    if n not in loop:
        loop = loop.add(n)
        stack.append(n)


def find_loop(d, n, block_list):
    """给定回边 n->d，确定此循环的全部节点
    参考蒋立源、康慕宁《编译原理》P314程序8-5
    loop : The set of blockNum in the loop
    """
    stack = list()
    loop = set()

    loop.add(d)
    __insert(n, loop, stack)
    while len(stack) > 0:
        m = stack.pop()
        block = block_list[m]
        for pre_block in block.preBasicBlock:
            __insert(pre_block.blockNum, loop, stack)
    return loop

def find_loop_exit(block_list, loop):
    """find the exit blocks of a loop
    return a list of blockNum
    """
    exit_blockNum = []
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for succ, _ in block.succBasicBlock:
            if not succ.blockNum in loop:
                exit_blockNum.append(block.blockNum)
    return exit_blockNum

def __is_operand_define_out_loop(inst, operand, var_ud, inst_set_of_loop):
    # TODO: complete it and rewrite function __mark_unchanged_computation
    if instruction.is_operand_a_variable(operand) is False:
        return True
    else:
        ud_in_L = tuple(var_ud & inst_set_of_loop)
        if len(ud_in_L) == 0:
            # definition is out of L
            return True
        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                    ud_in_L[0].changed_flag == True:
            # definition is in L and is a unchanged computation
            return True

def __mark_unchanged_computation(block_list, loop):
    """对于循环L中的四元式r，若 "它的各运算对象是常数，或者是定值点在L之外的变量"，或者
    "虽然在L中的某一点s定值，但该点是唯一能到达r的且已标记的定值点"，则标记四元式r
    参考蒋立源、康慕宁《编译原理》P315
    等价描述：先找到各运算对象是常数，或者是定值点在L之外的变量的四元式，处理这个四元式后，重复进行标记工作
    Parameters :
        block_list :
        loop : The set of blockNum in the loop
    Add unchanged_flag attribution for instructions in loop
    Attention: You must analysis reaching definitions first
    """
    inst_set_of_loop = set()
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            inst_set_of_loop.add(inst.pos)
            # init the unchanged_flag of all instructions
            inst.unchanged_flag = False
        changed_flag = True
        while changed_flag:
            changed_flag = False
            for inst in block:
                if inst.unchanged_flag == True:
                    continue
                # BinaryInst
                if isinstance(inst, instruction.BinaryInst):
                    left_flag = False
                    right_flag = False
                    # check left operand
                    if inst.is_left_a_variable is False:
                        left_flag = True
                    else:
                        left_ud = inst.left_ud
                        ud_in_L = tuple(left_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            left_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            left_flag = True
                    # check right operand
                    if inst.is_right_a_variable is False:
                        right_flag = True
                    else:
                        right_ud = inst.right_ud
                        ud_in_L = tuple(right_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            right_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            right_flag = True
                    # make a dicision
                    if left_flag and right_flag:
                        inst.unchanged_flag = True
                        changed_flag = True
                # UnaryInst
                elif isinstance(inst, instruction.UnaryInst):
                    if inst.is_variable_a_variable is False:
                        inst.unchanged_flag = True
                        changed_flag = True
                    else:
                        var_ud = inst.var_ud
                        ud_in_L = tuple(var_ud & inst_set_of_loop)
                        if len(ud_in_L) == 0:
                            # definition is out of L
                            inst.unchanged_flag = True
                            changed_flag = True
                        elif len(ud_in_L) == 1 and hasattr(inst, changed_flag) and \
                                                    ud_in_L[0].changed_flag == True:
                            # definition is in L and is a unchanged computation
                            inst.unchanged_flag = True
                            changed_flag = True

def __check_whether_expression_can_be_hoisted(block_list, loop, the_block, the_inst, D):
    """对循环L中每一个不变运算s:
        (s)  A := B OP C 或 A := OP B
       可以提出到循环外的运算必须满足下面条件：
        (1)s是L中A的唯一定值点。
        (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
        (3) a. s所在的基本块是L的各出口节点的必经节点
        或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
    """
    # (1)s是L中A的唯一定值点
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            if inst.pos == the_inst.pos:
                continue
            if isinstance(inst, instruction.BinaryInst) \
                or isinstance(inst, instruction.UnaryInst) \
                or isinstance(inst, instruction.StoreInst):
                if inst.value.name == inst.value.name:
                    return False
    # (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            if isinstance(inst, instruction.BinaryInst):
                if len(inst.left_ud) == 1:
                    # TODO: complete it
                    return False
    # (3) a. s所在的基本块是L的各出口节点的必经节点
    # 或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
    exit_blocks = find_loop_exit(block_list, loop)
    for block in block_list:
        if not block.blockNum in exit_blocks:
            continue
        if not the_block.blockNum in D[block.blockNum]:
            return False
    # 三个条件均满足，返回真
    return True

def __hoist_expression(block_list, loop, the_inst):
    """
    先查找循环的前置节点，再将符合条件的算式提前
    """
    # TODO: complete it
    pass

def hoist_loop_invariant_expressions(block_list, loop, D):
    """Loop-invariant expressions can be hoisted out of loops
        Attention: You must analysis reaching definitions first
        参考蒋立源、康慕宁《编译原理》P317。
        求出L中全部不变运算后，对每一个不变运算s:
        (s)  A := B OP C 或 A := OP B
        可以提出到循环外的运算必须满足下面条件：
             (1)s是L中A的唯一定值点。
             (2)对于A在L中的全部引用点，只有A在（s）的定值才能到达
             (3) a. s所在的基本块是L的各出口节点的必经节点
             或  b. 当控制从L的出口节点离开循环时，变量A不再活跃
        之后，可以按查找时的顺序，将符合条件的不变运算移至前置节点
    """
    # mark unchanged computation
    __mark_unchanged_computation(block_list, loop)
    # find computation which can be moved
    for block in block_list:
        if not block.blockNum in loop:
            continue
        for inst in block:
            if inst.unchanged_flag is True:
                if __check_whether_expression_can_be_hoisted(block_list, loop, block, inst, D):
                    # Loop-invariant expressions can be hoisted out of loops
                    __hoist_expression(block_list, loop, inst)



def do_loop_optimization(block_list):
    """the main function of Loop optimization
    """
    # find dominator
    D = find_dominator(block_list)
    # find loop
    loop_list = list()
    for n in range(len(D)):
        dom_set = D[n]
        for d in dom_set:
            for succ, description in block_list[n].succBasicBlock:
                if succ == block_list[d]:
                    print("find a back edge %d -> %d"%(n, d))
                    loop = find_loop(d, n, block_list)
                    loop_list.append(loop)
    print(loop_list)
    # analysis reaching definitions
    var_reduce = ud.reach_def_iteration(block_list)
    ud.ud_set(block_list, var_reduce)

    for loop in loop_list:
        # Loop-invariant expressions can be hoisted out of loops
        hoist_loop_invariant_expressions(block_list, loop, D)

